<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gsj.life</id>
    <title>Guo</title>
    <updated>2024-05-08T03:01:57.388Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gsj.life"/>
    <link rel="self" href="https://gsj.life/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://gsj.life/images/avatar.png</logo>
    <icon>https://gsj.life/favicon.ico</icon>
    <rights>All rights reserved 2024, Guo</rights>
    <entry>
        <title type="html"><![CDATA[Python类与继承]]></title>
        <id>https://gsj.life/post/python-lei-yu-ji-cheng/</id>
        <link href="https://gsj.life/post/python-lei-yu-ji-cheng/">
        </link>
        <updated>2024-05-08T02:54:34.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gsj.life/post-images/1715136880776.png" alt="" loading="lazy"></figure>
<pre><code>class Dog:
    def __init__(self,name,height,power):
        self.name =name
        self.height =height
        self.power = power
        self.blood = 100

    def speak(self):
        print(f'我是{self.name},身高{self.height},我的攻击力为{self.power}')

#牧羊犬
class SheepDog(Dog):
    def __init__(self,name,height,power,num_of_sheeps):
        super().__init__(name,height,power)
        self.num_of_sheeps = num_of_sheeps

# 警犬
class JingQian(Dog):
    def __init__(self,name,height,power,ability):
        super().__init__(name,height,power)
        self.ability =ability

# 宠物犬
class BabyDog(Dog):
    def __init__(self,name,height,power,price):
        super().__init__(name,height,power)
        self.price = price

sd = SheepDog('牧羊犬1',80,100,10)
print(sd.name,sd.height,sd.power,sd.blood,sd.num_of_sheeps)
sd.speak()

jq = JingQian('警犬1',120,200,5)
print(jq.name,jq.power,jq.ability,jq.blood)
jq.speak()

bd=BabyDog(&quot;宠物犬1&quot;,50,0,5000)
print(bd.name,bd.height,bd.power,bd.price,bd.blood)
bd.speak()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 面向对象练习2]]></title>
        <id>https://gsj.life/post/python-mian-xiang-dui-xiang-lian-xi-2/</id>
        <link href="https://gsj.life/post/python-mian-xiang-dui-xiang-lian-xi-2/">
        </link>
        <updated>2024-05-07T16:19:05.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gsj.life/post-images/1715098758645.png" alt="" loading="lazy"></figure>
<pre><code>class Car:
        def __init__(self,name,brand,max_people):
            self.name=name
            self.brand=brand
            self.number_of_people=0
            self.max_people=max_people
            def show(self):
                print(f'这是{self.brand}品牌的{self.name}汽车,限额{self.max_people}人,现在车上有{self.number_of_people}')

        def run(self):
            print(f'汽车{self.name}跑起来了')

        def set_people(self,number_of_people):
            if 0&lt;=number_of_people&lt;=self.max_people:
                self.number_of_people=number_of_people
            else:
                print(f'这是{self.brand}品牌的{self.name}汽车,限额{self.max_people}人,您想加入{number_of_people}人，超过限额人数!!')

        def increase_people(self):
            if self.number_of_people&lt;self.max_people:
                self.number_of_people+=1
            else:
                print(&quot;已经满员了&quot;)

        def reduce_people(self):
            if self.number_of_people&gt;0:
                self.number_of_people-=1
            else:
                print(&quot;不能再减了&quot;)

    byd=Car('仰望U8','BYD',8)
    byd.set_people(7)
    byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    # byd.reduce_people()
    bwm=Car('X5','BWM',5)
    bwm.increase_people()
    # bwm.increase_people()
    # bwm.increase_people()
    # bwm.increase_people()
    # bwm.increase_people()
    # bwm.increase_people()
    bwm.set_people(8)
    byd.show()
    bwm.show()
    byd.run()
    bwm.run()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python面向对象练习1]]></title>
        <id>https://gsj.life/post/python-mian-xiang-dui-xiang-lian-xi-1/</id>
        <link href="https://gsj.life/post/python-mian-xiang-dui-xiang-lian-xi-1/">
        </link>
        <updated>2024-05-07T15:57:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gsj.life/post-images/1715097486996.png" alt="" loading="lazy"></figure>
<pre><code>class Car:
    def __init__(self,name,brand):
        self.name=name
        self.brand=brand

    def show(self):
        print(self.name)
        print(self.brand)

    def run(self):
        print(f'汽车{self.name}跑起来了')


byd=Car('仰望U8','BYD')
bwm=Car('X5','BWM')
byd.show()
byd.run()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python类的实例]]></title>
        <id>https://gsj.life/post/python-lei-de-shi-li/</id>
        <link href="https://gsj.life/post/python-lei-de-shi-li/">
        </link>
        <updated>2024-05-07T15:28:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="创建一个狗类">创建一个狗类</h1>
<pre><code>class Dog:
</code></pre>
<h1 id="类的初始化函数-self表示当前创建的这个对象">类的初始化函数、self表示当前创建的这个对象</h1>
<pre><code>def __init__(self,name,age,sex,breed,power):
    # 初始化对象的属性值
    self.name = name
    self.age = age
    self.sex = sex
    self.breed = breed
    self.power = power
# 类的方法---要传入self表示当前正在创建的这个对象
def speak(self):
    print(f'I am {self.name}. I am {self.age} I am{self.sex},我现在的血量是{self.breed}')
def attack(self,dog2):
    dog2.breed = dog2.breed-self.power
</code></pre>
<h1 id="实例化通过类的实例化创建一个对象并传入属性的参数值">实例化，通过类的实例化创建一个对象，并传入属性的参数值</h1>
<pre><code>d1 = Dog('大黄',0.7,'公',15,5)
d2 = Dog('二黑',0.5,'母',10,3)

`print(d1.name,d1.age)`
`print(d2.name,d2.age)`
`#狗的方法 攻击--减少血量`
</code></pre>
<h1 id="类的方法的调用和对象属性值的修改">类的方法的调用和对象属性值的修改</h1>
<pre><code>d1.attack(d2)
d2.attack(d1)
</code></pre>
<h1 id="狗的方法-叫-狗现在的状态">狗的方法 叫--狗现在的状态</h1>
<pre><code>d1.speak()
d2.speak() 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[散射系数001]]></title>
        <id>https://gsj.life/post/san-she-xi-shu-001/</id>
        <link href="https://gsj.life/post/san-she-xi-shu-001/">
        </link>
        <updated>2024-05-07T08:39:58.000Z</updated>
        <content type="html"><![CDATA[<p>clc;<br>
clear;<br>
load(&quot;20210106150614_01_staring.mat&quot;)</p>
<p>% 假设已经加载了数据并有频率数据freq<br>
measured_sigma0 = calculateScatteringCoefficient(amplitude_complex_T1);  % 使用T1数据计算实测散射系数</p>
<p>% 假设已经有模型的数据<br>
freq = [1e9, 2e9, 3e9]; % 频率数组示例</p>
<p>%% GIT<br>
GrAng=0.3;<br>
alpha = GrAng;<br>
ThWind=0;<br>
Pol='H';<br>
SeaState=3;<br>
for ifreq = 1 : length(freq)<br>
GTI_SigZHor(ifreq) = GTI_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end<br>
GTI_SigmaHH = GTI_SigZHor;</p>
<p>%% NRL<br>
NRL_SigZHor = NRL_SigmaSea(freq,SeaState,Pol,alpha);<br>
NRL_SigmaHH=NRL_SigZHor;</p>
<p>%% HYB<br>
for ifreq = 1 : length(freq)<br>
HYB_SigZHor(ifreq) = HYB_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end<br>
HYB_SigmaHH=HYB_SigZHor;<br>
%% TSC<br>
for ifreq = 1 : length(freq)<br>
TSC_SigZHor(ifreq) = TSC_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end<br>
TSC_SigmaHH=TSC_SigZHor;<br>
%%<br>
modelSigmas.GTI = GTI_SigmaHH;  % GIT模型数据<br>
modelSigmas.NRL = NRL_SigmaHH;  % NRL模型数据<br>
modelSigmas.HYB = HYB_SigmaHH;  % HYB模型数据<br>
modelSigmas.TSC = TSC_SigmaHH;  % TSC模型数据<br>
% 绘制比较图<br>
plotScatteringCoefficients(freq, modelSigmas, measured_sigma0);</p>
<p>function sigma0 = calculateScatteringCoefficient(amplitude_complex)<br>
% 计算每个点的功率<br>
power_spectrum = abs(amplitude_complex).^2;  % I^2 + Q^2</p>
<pre><code>% 设置参考功率，例如1毫瓦（1e-3瓦特）
P_ref = 1e-3;

% 计算散射系数（dB）
sigma0 = 10 * log10(power_spectrum / P_ref);  % dB
</code></pre>
<p>end</p>
<p>function plotScatteringCoefficients(freq, modelSigmas, measuredSigma)<br>
% freq: 频率数组<br>
% modelSigmas: 结构体，包含不同模型的散射系数数据<br>
% measuredSigma: 实测散射系数数组<br>
figure;<br>
semilogx(freq, modelSigmas.GTI, 'r-', freq, modelSigmas.NRL, 'k-', freq, modelSigmas.HYB, 'b-', freq, modelSigmas.TSC, 'g-', freq, measuredSigma, 'm--');<br>
hold on;<br>
legend('GIT', 'NRL', 'HYB', 'TSC', 'Measured');<br>
xlabel('Frequency (Hz)');<br>
ylabel('Scattering Coefficient (dB)');<br>
title('Comparison of Scattering Coefficient Models and Measurement');<br>
grid on;<br>
end</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[散射系数仿真]]></title>
        <id>https://gsj.life/post/san-she-xi-shu-fang-zhen/</id>
        <link href="https://gsj.life/post/san-she-xi-shu-fang-zhen/">
        </link>
        <updated>2024-05-06T07:18:27.000Z</updated>
        <content type="html"><![CDATA[<p>要将海杂波的实测数据与散射系数模型进行对比，你需要完成以下几个关键步骤：准备数据、选择散射系数模型、计算散射系数、绘图对比。下面是这些步骤的详细描述和相应的 MATLAB 代码示例。</p>
<p>步骤 1: 准备数据<br>
首先，加载实测的海杂波数据和任何需要的模型参数。这通常涉及到从 .mat 文件中读取数据和相关的雷达参数，如脉冲宽度、频率、距离等。</p>
<p>matlab<br>
Copy code<br>
% 加载实测数据<br>
data = load('radar_data.mat');<br>
amplitude_T1 = data.amplitude_complex_T1;  % 实测数据<br>
info = data.amplitude_complex_info;        % 包含雷达参数的信息</p>
<p>% 提取需要的参数<br>
frequency = info(1, 10);  % 例如，假设频率存放在第10列<br>
distance = 5000;          % 假设距离为5000米<br>
步骤 2: 选择和应用散射系数模型<br>
选择适合的散射系数模型进行预测。假设你有预先定义好的模型函数。</p>
<p>matlab<br>
Copy code<br>
% 模型函数示例<br>
function sigma0 = nrlModel(frequency, distance)<br>
% 一个假设的散射系数计算，基于NRL模型<br>
sigma0 = 0.1 * frequency / distance^2;<br>
end<br>
步骤 3: 计算散射系数<br>
从实测数据计算散射系数，以及使用模型预测散射系数。</p>
<p>matlab<br>
Copy code<br>
% 计算实测数据的散射系数<br>
Pr_measured = abs(amplitude_T1).^2;  % 计算接收功率<br>
sigma0_measured = 10 * log10(Pr_measured / (distance^2));  % 简化公式计算散射系数</p>
<p>% 使用模型计算散射系数<br>
sigma0_predicted = nrlModel(frequency, distance);<br>
步骤 4: 绘图对比<br>
绘制实测数据和模型预测的散射系数进行对比。</p>
<p>matlab<br>
Copy code<br>
figure;<br>
plot(sigma0_measured, 'b-', 'DisplayName', 'Measured');<br>
hold on;<br>
plot(sigma0_predicted, 'r--', 'DisplayName', 'Predicted by Model');<br>
xlabel('Sample Index');<br>
ylabel('Sigma0 (dB)');<br>
title('Comparison of Measured and Modeled Scattering Coefficients');<br>
legend show;<br>
完整的 MATLAB 代码示例<br>
matlab<br>
Copy code<br>
% 加载和准备数据<br>
data = load('radar_data.mat');<br>
amplitude_T1 = data.amplitude_complex_T1;<br>
info = data.amplitude_complex_info;<br>
frequency = info(1, 10);<br>
distance = 5000;</p>
<p>% 计算实测散射系数<br>
Pr_measured = abs(amplitude_T1).^2;<br>
sigma0_measured = 10 * log10(Pr_measured / (distance^2));</p>
<p>% 模型预测散射系数<br>
sigma0_predicted = nrlModel(frequency, distance);</p>
<p>% 绘图对比<br>
figure;<br>
plot(sigma0_measured, 'b-', 'DisplayName', 'Measured');<br>
hold on;<br>
plot(sigma0_predicted, 'r--', 'DisplayName', 'Predicted by Model');<br>
xlabel('Sample Index');<br>
ylabel('Sigma0 (dB)');<br>
title('Comparison of Measured and Modeled Scattering Coefficients');<br>
legend show;</p>
<p>% 模型函数<br>
function sigma0 = nrlModel(frequency, distance)<br>
sigma0 = 0.1 * frequency / distance^2;<br>
end<br>
这个过程允许你清楚地看到实测数据与理论模型之间的差异，并可用于进一步分析和模型调整。在实际应用中，你可能需要根据实测数据的特性调整模型参数或选择不同的模型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[海杂波散射仿真]]></title>
        <id>https://gsj.life/post/2UXPupqQ5/</id>
        <link href="https://gsj.life/post/2UXPupqQ5/">
        </link>
        <updated>2024-05-04T14:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>clc;<br>
c = 2.997924562e8; %Speed of Light 光速<br>
dtor = pi/180; %5角度转换为弧度<br>
% GrAng=app.GrAngEditField.Value;<br>
GrAng=app.GrAngSlider.Value;<br>
app.currentNumEditField.Value=GrAng;<br>
phi=app.phiSpinner.Value;<br>
ThWind =app.ThWindSpinner.Value;<br>
Pol=app.PolDropDown.Value;<br>
% GrAng =[0.3];<br>
NGrAng = length(GrAng);%定义擦射角的数组的长度<br>
% ThWind = 0;<br>
% phi = 0;</p>
<p>% freq = (0.5:0.1:40);<br>
% freq = app.fromEditField.Value;<br>
fx=app.fromSpinner.Value;<br>
step=app.stepSpinner.Value;<br>
fm=app.ToSpinner.Value;<br>
freq = (fx:step:fm);%fx为起始值，step为步长，fm为序列的结束值<br>
fMin=freq(1);<br>
fMax=max(freq);<br>
fMax=freq(end);</p>
<p>% Variables for computing average abs deviation 计算平均误差<br>
SumDevH = 0.0;<br>
NValH = 0;<br>
SumDevV = 0.0;<br>
NValV = 0;</p>
<p>phi_rad = phi .* dtor;<br>
% GRAPHICS DEFINITIONS 图形定义<br>
ha=[];hl=[];hp=[];ht=[];htx=[];hty=[];<br>
set(0,'Units','pixels')</p>
<p>% Set SCreen Size 定义屏幕尺寸<br>
scnsize=get(0,'ScreenSize');<br>
pos1 = [5+scnsize(1),0.02<em>scnsize(4),.99</em>scnsize(3),.75*scnsize(4)];</p>
<p>FigFont = 28;<br>
CircSize = 14;<br>
LineSize = 7;<br>
AxWidth = 4;</p>
<p>% Initialize figure number 初始化图号</p>
<p>% Defines units for values returned by ScreenSize 定义ScreenSize返回值的单位</p>
<p>% Define colors for curves and points 定义曲线和点的颜色<br>
Cols = 'bgrcmyk';</p>
<p>ColsMat = [ 0.161 0.698 0.725; % magenta<br>
0.608 0.18 0.8; % violet<br>
1.0 0.0 0.0; % red<br>
0.541 0.416 0.361; % brown<br>
0.0 0.0 0.0; % black<br>
1 0 1;% dark green<br>
0.067 0.204 0.898 ];%  dark blue<br>
cla(app.UIAxes14, 'reset');<br>
cla(app.UIAxes_4, 'reset');<br>
cla(app.UIAxes14_2, 'reset');<br>
cla(app.UIAxes14_3, 'reset');<br>
cla(app.UIAxes14_4, 'reset');<br>
%########################################################################<br>
% ALL GRAZING ANGLES 所有的擦射角<br>
% Do all sea states for HH  H极化下的海况。<br>
%% GIT<br>
for SeaSt=0:6<br>
SeaState=SeaSt;<br>
SS_Plus1 = SeaState + 1;</p>
<p>for ifreq = 1 : length(freq)<br>
GTI_SigZHor(ifreq) = GTI_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end</p>
<p>GTI_SigmaHH = GTI_SigZHor;</p>
<p>% Plot empirical curve first<br>
semilogx(app.UIAxes14,freq,GTI_SigmaHH,'Color',ColsMat(SeaSt+1,:));<br>
legend(app.UIAxes14,'GrAng =0.3 SeaState=1','GrAng =0.3 SeaState=2','GrAng =0.3 SeaState=3','GrAng =0.3 SeaState=4','GrAng =0.3 SeaState=5','GrAng =0.3 SeaState=6',Location='southeast')<br>
hold(app.UIAxes14,&quot;on&quot;)<br>
grid(app.UIAxes14,'on');<br>
xlabel(app.UIAxes14,'频率(GHz) ','FontSize',14);<br>
ylabel(app.UIAxes14,'散射系数 - \sigma_{HH}^o (dB)','FontSize',14);<br>
title(app.UIAxes14,'GIT模型HH极化','FontSize',14)<br>
end<br>
%% NRL<br>
for SeaSt=0:6<br>
SeaState=SeaSt;<br>
SS_Plus1 = SeaState + 1;</p>
<p>NRL_SigZHor = NRL_SigmaSea(freq,SeaState,Pol,alpha);<br>
NRL_SigmaHH=NRL_SigZHor;</p>
<p>% Plot empirical curve first</p>
<p>hl(end+1) = semilogx(app.UIAxes14_2,freq,NRL_SigmaHH);<br>
legend(app.UIAxes14_2,'GrAng =0.3 SeaState=1','GrAng =0.3 SeaState=2','GrAng =0.3 SeaState=3','GrAng =0.3 SeaState=4','GrAng =0.3 SeaState=5',Location='southeast')<br>
hold(app.UIAxes14_2,&quot;on&quot;)<br>
xlabel(app.UIAxes14_2,'频率(GHz) ','FontSize',14);<br>
ylabel(app.UIAxes14_2,'散射系数 - \sigma_{HH}^o (dB)','FontSize',14);<br>
title(app.UIAxes14_2,'NRL模型HH极化','FontSize',14)<br>
grid(app.UIAxes14_2,'on');<br>
end<br>
%% HYB<br>
for SeaSt=0:6<br>
SeaState=SeaSt;<br>
SS_Plus1 = SeaState + 1;</p>
<p>for ifreq = 1 : length(freq)<br>
HYB_SigZHor(ifreq) = HYB_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end<br>
HYB_SigmaHH=HYB_SigZHor;<br>
% Plot empirical curve first<br>
hl(end+1) = semilogx(app.UIAxes14_3,freq,HYB_SigmaHH);<br>
legend(app.UIAxes14_3,'GrAng =0.3 SeaState=1','GrAng =0.3 SeaState=2','GrAng =0.3 SeaState=3','GrAng =0.3 SeaState=4','GrAng =0.3 SeaState=5',Location='southeast')<br>
hold(app.UIAxes14_3,&quot;on&quot;)<br>
xlabel(app.UIAxes14_3,'频率(GHz) ','FontSize',14);<br>
ylabel(app.UIAxes14_3,'散射系数 - \sigma_{HH}^o (dB)','FontSize',14);<br>
title(app.UIAxes14_3,'HYB模型HH极化','FontSize',14)<br>
grid(app.UIAxes14_3,'on');<br>
end<br>
%% TSC<br>
for SeaSt=0:6<br>
SeaState=SeaSt;<br>
SS_Plus1 = SeaState + 1;</p>
<p>for ifreq = 1 : length(freq)<br>
TSC_SigZHor(ifreq) = TSC_SigmaSea(freq(ifreq),SeaState,Pol,alpha,ThWind);<br>
end<br>
TSC_SigmaHH=TSC_SigZHor;<br>
% Plot empirical curve first<br>
hl(end+1) = semilogx(app.UIAxes14_4,freq,TSC_SigmaHH);<br>
legend(app.UIAxes14_4,'GrAng =0.3 SeaState=1','GrAng =0.3 SeaState=2','GrAng =0.3 SeaState=3','GrAng =0.3 SeaState=4','GrAng =0.3 SeaState=5',Location='southeast')<br>
hold(app.UIAxes14_4,&quot;on&quot;)<br>
% set(hl(end),'Color',ColsMat(SeaSt+1,:));<br>
xlabel(app.UIAxes14_4,'频率(GHz) ','FontSize',14);<br>
ylabel(app.UIAxes14_4,'散射系数 - \sigma_{HH}^o (dB)','FontSize',14);<br>
title(app.UIAxes14_4,'TSC模型HH极化','FontSize',14)<br>
grid(app.UIAxes14_4,'on');<br>
end</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git快速下载链接 ]]></title>
        <id>https://gsj.life/post/DXd11Sq0C/</id>
        <link href="https://gsj.life/post/DXd11Sq0C/">
        </link>
        <updated>2024-05-04T14:15:47.000Z</updated>
        <content type="html"><![CDATA[<p>git快速下载链接 （2024年3月12日22点40分有效)<br>
https://ximfem.lanzoul.com/iey9g0k1stpe?w1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++]]></title>
        <id>https://gsj.life/post/q5I5UU4Ol/</id>
        <link href="https://gsj.life/post/q5I5UU4Ol/">
        </link>
        <updated>2024-05-04T13:40:36.000Z</updated>
        <content type="html"><![CDATA[<p>c++列表</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章入门C++]]></title>
        <id>https://gsj.life/post/u2ww3-SQN/</id>
        <link href="https://gsj.life/post/u2ww3-SQN/">
        </link>
        <updated>2024-05-03T14:53:15.000Z</updated>
        <content type="html"><![CDATA[<p>为什么要学习C++：<br>
       抛开C++在一些物联网，高性能引擎（游戏等）及各种操作系统等行业使用的专业性，不论作为java开发还是其他开发，我们的知识体系里面必不可少的定有操作系统相关的知识，而关于操作系统，如果我们想要更深入的了解的话，看懂它的一些代码当然是必不可少的。再或者，开发一些高性能的工具或者组件,这些，都离不开C和C++，而对于C++的学习其实就基本上已经学会了C的一些东西（如果以前没有接触过C的话），基于二八法则，基本已够用。<br>
C++语言的由来：<br>
       1982年，美国AT&amp;T公司贝尔实验室的Bjarne Stroustrup(本贾尼·斯特劳斯特卢普)博士在C语言的基础上引入并扩充了面向对象的概念，从而创造了C++这门程序语言，也叫做带类的C（c with class）。Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）博士也被尊称为C++语言之父。<br>
推荐c++学习开发工具<br>
  windows上使用vc即可，mac上使用xcode即可<br>
强烈推荐使用Qt creator 学习开发，也可以学习下Qt库<br>
C++语法<br>
认识C++的对象:<br>
C++的函数和对象：</p>
<p>注释方式(基本与java注释类似)</p>
<p>arduino复制代码/<em>....</em>/<br>
//....</p>
<p>输入输出流<br>
cin和cout是C++语言中进行输入输出操作的函数，定义在istream头文件中。<br>
例子：</p>
<p>bash复制代码cout &lt;&lt; &quot;&quot; &lt;&lt; endl;  //c代表c系语言，out代表输出，endl代表换行</p>
<p>使用命名空间<br>
命名空间是C++语言中封装程序库名称的一种机制<br>
C++ 标准类库中的对象和函数都属于std命名空间，使用这些函数和对象时要using namespace std<br>
arduino复制代码#include &quot;iostream&quot; //包含头文件<br>
#include &quot;cmath&quot;<br>
using namespace std</p>
<p>使用std命名空间时注意：<br>
使用c语言中的头文件时，要写成“xxx.h”形式<br>
使用c++中的头文件则不能加上“.h”<br>
命名空间可自定义，可嵌套，比如小王定义的是A命名空间，小李定义的是B命名空间，就算他们的函数重名了，一摸一样了也没事，可以通过命名空间::函数名来调用。</p>
<p>对象的定义及初始化<br>
c语言：int x; x=0; 等价于 int x=0;<br>
c++ 语言（等价于上两条c语句）：int x(0); 此种初始化语法在c++中称为构造函数语法<br>
函数原型及其返回值<br>
函数要有类型，若要得到处理结果则要使用return语句（与java类似，其实java的面世很多都是参考c++）。<br>
例子：<br>
int result(int a,int b){  int d;  d = a+b;  return d;     }<br>
函数调用在函数定义之前时要对函数进行声明<br>
例子：<br>
int result(int a,int b); //进行函数声明     void main(){ //主函数 ... z = result(x ,y); //调用定义的函数 ...     }     int result(int a,int b){ //定义函数 int d; d = a+b; return d;     }<br>
const修饰符和预处理程序<br>
常量定义：（在c语言中是这样定义的，注意c++语法包含容纳c语法，c++就像是对c的一个扩充） #define PI 3.1415<br>
(在c++中是这样定义的) 在变量定义之前加上const关键字，类似java，表示定义的变量值不可改变。<br>
const int PI = 3.1415; （第一种）<br>
const int PI(3.1415); （第二种，即构造函数语法）<br>
利用const定义常量时必须给出常量的值，除非该常量是extern（外部变量、即全局变量）的。<br>
以#开始，分为宏定义，文件包含和条件编译。<br>
程序的书写规则<br>
注意缩进对齐，区分大小写，类似java，有所不同。</p>
<p>C++语言面向过程编程的特点</p>
<p>函数重载<br>
（与java类似）C++允许一个函数定义多个版本，使得一个函数完成多种功能，即同一个函数名定义多次。<br>
例子：<br>
css复制代码 int max(float a,float b){<br>
return a &gt; b ? a:b;<br>
}</p>
<p>int max(int a,int b,int c){<br>
int d;<br>
d = a &gt; b ? a:b;<br>
return d &gt; c ? d:c;<br>
}<br>
int max(int a,int b){<br>
return a&gt;b ? a:b;<br>
}</p>
<p>如例子所示，重载函数的特点：<br>
函数名相同，参数个数不同，或者参数类型不同。</p>
<p>C++的数据类型（包括java等，几乎所有有语言的数据类型都囊括这些）<br>
1.void类型<br>
void表示空类型，或者无类型，表示函数无返回值。<br>
2.bool类型（逻辑型，布尔型）<br>
占1个字节，表示逻辑运算符中的 真 、假。<br>
3.整型（int、  long、 short）<br>
int、short至少16位<br>
long至少32位<br>
short不得比int长<br>
int 不得比long长<br>
4.char型（字符型）<br>
占1个字节。<br>
5.实型（float/double/long  double）<br>
我们可以通过sizeof来观察这些数据类型的长度<br>
例子：<br>
c复制代码 cout &lt;&lt; sizeof(bool) &lt;&lt; endl;<br>
cout &lt;&lt; sizeof(int) &lt;&lt; endl;<br>
cout &lt;&lt; sizeof(short) &lt;&lt; endl;<br>
cout &lt;&lt; sizeof(long) &lt;&lt; endl;<br>
cout &lt;&lt; sizeof(char)  &lt;&lt; endl;<br>
cout &lt;&lt; sizeof(float) &lt;&lt; endl;<br>
......</p>
<p>6.&amp;取地址符（取某一个变量的地址）<br>
例子：<br>
css复制代码int x;<br>
int *p;  //p是指针变量，指针变量能存放变量的地址<br>
p = &amp;x; //&amp;x表示取出变量x的地址，p = &amp;x表示将变量x的地址取出后存入指针变量p</p>
<p>7.常量表示<br>
整型：<br>
0前缀表示8进制数，0x前缀表示16进制数，加L、I后缀表示长整型常量<br>
实型：<br>
F、f后缀表示浮点型常量（float）；<br>
实数加L、I后缀表示long double类型；<br>
无前缀、无后缀的为double类型；</p>
<p>动态分配内存<br>
new动态分配内存<br>
一般格式： 指针变量 = new 类型[size];<br>
new 运算符得到新分配空间的首地址、赋值给指针变量后，可根据指针变量的加减运算来使用这些空间。<br>
（与java不同，java有垃圾回收机制，自动释放内存，而c++是没有的）<br>
delete 释放内存，使用完毕后要释放内存。<br>
delete p;</p>
<p>引用的使用方法<br>
引用即使用变量的别名。<br>
定义形式：数据类型 &amp; 别名 = 对象名；<br>
作用：别名与对象名对应同一个对象，共用同一段内存。对别名的修改会造成原对象的修改。<br>
例子：<br>
int x;     int &amp; a = x; //a是变量x的别名，a和x完全等价<br>
使用别名时的注意事项：<br>
1.不能定义引用的引用，如错误示范： int &amp; &amp;r=x;<br>
2.不能直接定义数组的引用</p>
<p>arduino复制代码使用typedef定义某类型的别名</p>
<p>arduino复制代码一般格式：typedef 类型 类型别名<br>
例子：</p>
<pre><code>typedef long int lint; 
//long int i;
lint i; //lint i 等价于 long int i
</code></pre>
<p>对指针使用const限定符<br>
1.左值和右值<br>
表达式：E1 = E2 ； E1是左值，是可被修改的；<br>
int *p,x = 1;<br>
*p = 2;  &amp;p表示指针p的地址<br>
2.指向常量的指针和常量指针<br>
const常量定义：表示const后的表达式不可改变，定义时必须给出表达式的值。<br>
例子：<br>
int x = 11;     const int *p; //错误写法，必须初始化     const int *p = &amp;x; //错误写法，<em>p是不能在=的左边     int * const p = &amp;x; //正确写法（注意：p不可改变，但是</em>p可变）</p>
<p>复制代码3.指向常量的常量指针</p>
<p>ini复制代码例子：</p>
<pre><code>int x = 11;
const int * const p = &amp;x; //表示p不可变，*p也是不可变的
</code></pre>
<p>泛型算法应用于普通数组<br>
泛型算法是C++标准模版库（Standard Template Library）提供的一组操作。利用这些操作可以简化数组操作。<br>
要使用这些操作必须包含头文件<algorithm><br>
假定a,b是两个数组名，其长度为len<br>
例子：<br>
reverse(a,a+len); //将数组a中的元素顺序反转（逆向），注意，len需要替换成长度，比如len=5，则len应该换成5     copy（a,a+len,b）; //将a数组的内容原样复制给b数组      reverse_copy(a,a+len,b); //将a数组的内容反转后复制给b数组       sort(a,a+len) ;//将数组a中的元素按升序排序      sort(a,a+len,greater<type>()) ;//将数组a中的元素按降序排序，type是数据类型，比如type是int，应该将type替换成int       find(a,a+len,value);//在数组a中查找值为vavlue的元素，并返回位置指针       copy(a,a+len,Ostream_iterator<type>(cout,&quot;分隔字符串&quot;)); //Ostream_iterator表示输出流操作符，<type>表示要输出的数组类型，cout表示流输出操作，“分隔字符串”即就是分隔字符的</p>
<p>程序的编辑、翻译、运行<br>
程序从无到有为编辑，出来的c++源代码<br>
对比C和C++文件的各种后缀（由于历史原因，可谓花样真多，现在只展示统一的）：</p>
<p>语言头文件源文件c.h.cc++.h,但是openCV采用 .hppwindows平台 .cpp,linux平台 .cc源码进行编译为翻译        c++的编译器有不少，其中熟知的有MSVC、GCC、Cygwin、MingW（Cygwin和MingW的英文发音），另外还有些    小众和新秀，像ICC（Intel C/C++ Compiler）、BCC（Borland C/C++ Compiler，快销声匿迹了）、RVCT    （ARM的汇编/C/C++编译器，内置在ARM的IDE——RVDS中）、Pgi编译器……<br>
我们在linux下最常用的：<br>
GCC原名GNU C Compiler，后来逐渐支持更多的语言编译（C++、Fortran、Pascal、Objective-C、         Java、Ada、Go等），所以变成了GNU Compiler Collection（GNU编译器套装），是一套由GNU工程开发的支    持多种编程语言的编译器。GCC是自由软件发展过程中的著名例子，由自由软件基金会以GPL协议发布，是大多数类      Unix（如Linux、BSD、Mac OS X等）的标准编译器，而且适用于Windows（借助其他移植项目实现的，比如        MingW、Cygwin等）。GCC支持多种计算机体系芯片，如x86、ARM，并已移植到其他多种硬件平台.<br>
有时候，在linxu中下载一些第三方工具，提示我们需要下载相关gcc依赖等，就是因为这个工具由于c++开发，需要使用gcc进行编译才可执行使用。</p>
<p>执行即为c++编译后的文件，进行汇编和链接后的执行<br>
从结构到类的演变：<br>
结构的演化：</p>
<p>结构发生质的演变<br>
1.函数与数据共存<br>
c++允许结构中定义的函数，成为成员函数。在结构中同时定义成员变量和成员函数。<br>
使用格式：<br>
结构对象.成员变量<br>
结构对象.成员函数<br>
例子：</p>
<pre><code>#include    //引入头文件 io
using namespace std; //使用c++标准类库中的类，需要使用std命名空间
struct point{ //point即为结构名，结构是c++中的一种数据结构,类似类
double x,y;
void updatexy(double a, double b){
x = a;
y = b;
}
void display(){
cout &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; y &lt;&lt; endl; //endl是换行的意思
}
}; //注意结构数据定义完后要有分号


csharp复制代码void main(){

css复制代码 point p; //表示定义了p，与java不一样的是，这个p已经包含了java中= new .. 后面的动作，所以可直接调用p
 p.updatexy(1.5,1.7);
 p.display();
 cout &lt;&lt; p.x &lt;&lt; &quot;\t&quot; &lt;&lt; p.y &lt;&lt; endl;
}
</code></pre>
<p>2.封装<br>
如果定义结构体时，使用了private关键字，则产生封装性。<br>
例子：<br>
csharp复制代码struct point{<br>
private: //这里区别于java，可以只写一个private，所有private的放在其下<br>
double x,y;  //这时候，在main中，通过point的变量名直接 . 变量，就不行了<br>
public:  //区别于java，可以只写一个public....<br>
void updatexy(double a,double b){<br>
x = a;<br>
y = b;<br>
}<br>
void display(){<br>
cout &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;<br>
}<br>
};</p>
<p>在定义结构时，如果使用了private则产生封装性，表示成员为私有的，只能在结构体内部通过公有成员函数使用。如果未添加private，则表示默认为public。值得注意的是类在定义时默认却为private。</p>
<p>使用构造函数初始化结构的对象<br>
在定义结构时，与结构同名的函数称为构造函数。<br>
如果定义的函数与某个已定义函数重名而参数类型或者个数不同，则称为函数重载。<br>
例子：</p>
<p>ini复制代码struct point{<br>
private:<br>
double x,y;<br>
public:<br>
point(){};<br>
point(doube a,double b){<br>
x = a;<br>
y = b;<br>
}<br>
void updatexy(....){ ... }<br>
.....<br>
}</p>
<p>与java的类类似，构造函数在定义结构体对象时自动执行，并根据是否初始化来自动选择所调用的构造函数。<br>
这里需要区分的是：java的对象定义，在定义后，如果不new对象，它的变量名对应的对象则为null（这个null需要我们给赋给其），如果new对象的话，不仅会创建一个对象，还会自动进行初始化，也就是java的对象创建流程里面已经包含了初始化。但是c++则不一样，（c++也有new对象的方式，new出来的为动态对象）c++定义好后，就已经有这个对象了，但是初始化的过程由我们来控制，可以调用有参数的构造函数，那在对象定义完成后，也已经完成了初始化过程。<br>
结构演化成一个简单的类：<br>
将结构的struct替换为class即变为类的标准定义形式。<br>
例子：<br>
ini复制代码class point{<br>
private:<br>
double x,y;<br>
public:<br>
point(){};<br>
point(double a,double b){<br>
x = a;<br>
y = b;<br>
};<br>
void updatexy(double a,double b){<br>
x = a;<br>
y = b;<br>
}<br>
void display(){<br>
cout &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;<br>
}<br>
};</p>
<p>类图的表示（UML即统一建模语言等）：</p>
<p>point-x : double   -y : double+point()   +updatexy() +display()其中，point为类名，x，y为类属性（成员变量），point和updatexy、display为类操作（成员函数）。<br>
面向过程和面向对象：<br>
直观的从一道题来区分：<br>
给出两点坐标，计算亮点间距，并输出。<br>
1.面向过程的求解步骤 ：<br>
步骤：</p>
<ul>
<li>输入x1，y1,x2,y2 四个数据<br>
计算（x1,y1）和 (x2,y2)的距离<br>
输出计算出的距离<br>
2.面向对象的求解步骤</li>
<li>设计类<br>
将点设计为一个类，并提供相关的属性和操作<br>
定义对象同时给出坐标<br>
point A(x1,y1)<br>
point B(x2,y2)<br>
定义对象，然后获取坐标<br>
计算距离并输出<br>
C++面向对象程序设计特点</li>
</ul>
<p>对象<br>
三要素：对象名，属性，操作</p>
<p>使用类和对象</p>
<p>使用类和对象<br>
1.使用string对象</p>
<p>string- str+string()   +find() +size()  +substr该类是c++语言中的内部预定义类，要在程序中使用该类时必须添加头文件  #include <string>  ；<br>
**注意:**头文件引入的两种写法，#include  &lt;...&gt; 和 #include &quot;...&quot;  。<br>
类的初始化：string str1 = &quot;A&quot;;<br>
string str1(&quot;hello  &quot;);<br>
string str2 = &quot;world&quot;;<br>
与java类似，string对象允许使用 + 运算</p>
<ul>
<li>使用complex对象<br>
complex类用于定义一个复数对象，使用时添加头文件 #include <comlex><br>
定义格式：complex <int> num1(1,2);</li>
<li>使用对象总结<br>
使用标准类库中的类时，必须添加头文件。<br>
定义对象方式同变量定义方式类似。<br>
定义对象时可对对象进行初始化。<br>
同类的不同对象由对象属性来区分。<br>
不同类的对象具有不同的成员函数可实现不同操作。<br>
类是具有相同特征和操作的对象的抽象。<br>
函数和函数模版<br>
函数的参数及其传递方式<br>
c语言中参数传递方式只有一种：值传递（值传递分为变量值传递和变量地址值传递）。<br>
c++中分为：值传递和地址传递（引用传递），与java类似。<br>
参数不同传递形式：对象作参数，对象指针作参数，对象引用作参数。<br>
引用的声明形式：<br>
数据类型 &amp;别名 = 对象名；<br>
int x = 21;<br>
int &amp;a = x;<br>
引用对象不是一个对立对象，与原对象同用一个地址空间，不占用内存。<br>
对象的指针作参数时，指针变量中存放实参对象的地址。<br>
函数的返回值<br>
与java类似，但是多了指针类型。<br>
内联函数<br>
定义函数时，加inline关键字表示该函数为内联函数。<br>
例子：<br>
arduino复制代码inline int wheatherNumber(char c){<br>
return c &gt; '0' &amp;&amp; c &lt; '9' ? 1:0;<br>
}</li>
</ul>
<p>程序中的内联函数在程序编译时，将函数替换至程序中函数调用位置，造成程序变长，效率提高。<br>
注意事项：<br>
内联函数中不能出现循环、switch语句等<br>
内联函数一般短小，不宜过长<br>
应在调用之前声明或定义<br>
函数模版<br>
有些函数重载时参数个数相同，只是类型不同，此时重载函数比较繁琐，可利用函数模版实现。<br>
例子：<br>
ini复制代码template <class type><br>
type max(type a , type b){<br>
return a &gt; b ? a:b;<br>
}</p>
<p>void main(){<br>
int x = 1,y = 2;<br>
double x1 = 1.2,y = 2.1;</p>
<p>int z;<br>
double z1;</p>
<p>z = max(x,y);<br>
z1 = max(x1,y1);<br>
cout &lt;&lt; &quot;最大值：int类型为 &quot; &lt;&lt; z &lt;&lt; &quot;  dobule类型为  &quot; &lt;&lt; z1 &lt;&lt;endl;</p>
<p>}</p>
<p>定义函数模版后，函数调用时根据函数参数类型来确定调用哪个版本的函数。函数执行时确定参数类型的函数称为模版函数。<br>
类和对象<br>
类及其实例化</p>
<p>类的定义<br>
例子模版：</p>
<pre><code>class 类名{
private:
//私有的数据成员和成员函数
public:
//公有的数据成员和成员函数
protected:
//保护的数据成员和成员函数
};
void 类名::函数名(){
}


go复制代码```  


:: 称为域限定符，表示函数是类的成员函数。在类外使用域限定符定义函数，若想定义为内联，加inline关键字就即可。
类内定义的函数默认为内联函数。

使用类的对象
类的对象的使用类似变量的使用。
声明/定义对象，直接利用对象名使用，通过对对象的引用使用对象，通过指向对象的指针使用对象。
数据封装
与结构体封装类似

构造函数


默认构造函数
若类的定义中未定义构造函数，则c++编译器会自动产生一个不带参数的默认构造函数，类似于：point(){},此时不对对象进行初始化。若类中定义了构造函数，则不再产生默认构造函数。


定义构造函数
构造函数无返回值，这样可以减少编译器的工作，提高效率。
构造函数与类同名。
构造函数可以重载。
构造函数系统自动调用。


构造函数和运算符new
new 和构造函数一同起作用，即new首先给对象分配内存，然后自动调用构造函数来初始化这块内存。
例子：
</code></pre>
<p>void main(){<br>
Point *ptr = new Point;<br>
Point *ptr1 = new Point(1,2);<br>
delete ptr;<br>
delete ptr1;<br>
}</p>
<pre><code>new建立的动态对象只能用delete删除，并会释放空间。


复制构造函数
&lt;类名&gt;::&lt;复制初始化构造函数&gt;(const 类名 &amp;引用名)


析构函数
           析构函数的调用由编译器自动调用，析构函数名在类名前加～，析构函数无返回值，析构函数无参数，可以显示说明为void，析构函数不可以重载，析构函数在对象生命周期结束的时候由系统自动调用。


定义析构函数
例子：
arduino复制代码class Point{
 private:
        int x,y;
 public :
        Point(const Point&amp;);
        Point(int a = 10,int b = 10);
        ~Point();
   
}
   ……

类的对象组的每个元素调用一次构造函数，调用一次析构函数。
全局对象数组的析构函数在程序结束之前会被调用。


析构函数和运算符delete
delete后自动调用析构函数。与new 相反。


默认析构函数
编译器为没有析构函数的类自动产生一个空体析构函数，与构造函数类似。
分配几次内存调用几次构造函数，释放几次内存，调用几次析构函数。


this指针
       this指针是c++实现粉状的一种机制，它将对象和该对象调用的成员函数连接在一起。this指针保证了每个对象可以拥有自己的数据成员。（跟java类似）
例子：
ini复制代码Point::Point(int a=0,int b=0){
 this-&gt;x=a;
 this-&gt;y=b;
}
point::Point(const Point &amp;p){
  this-&gt;x=p.x;
  this-&gt;y=p.y;
}

类和对象的性质

对象的性质
1.同一类的对象之间可以互相赋值；
2.可以使用对象数组；
3.可以使用指向对象的指针；
4.对象可以用作函数参数；
5.对象作为函数参数时，可以使用对象、对象引用和对象指针；
6.一个对象可以用作另一个类的成员。
类的性质
1.使用类的权限
2.不完全的类声明
只有当使用类产生的对象时，才进行内存分配。
类没有完全定义之前就引用该类。
不完全声明仅用于类和结构
3.空类
4.类作用域
类中默认控制权限是private

面向对象编程的文件规范

编译指令
在头文件中使用条件编译
#if
...

特殊函数和成员
静态成员
成员定义时使用static关键字
1.静态成员变量的初始化只能在类外进行。
2.类中的任何成员函数都可以访问静态成员变量。
3.访问静态成员时，一般加上类名限定。
4.静态成员变量是类的成员，不是对象的成 员。
5.对象未建立之前静态成员已经存在。
6.静态成员没有this指针，除非使用引用方式，否则不能存取类的成员。（与java类似，但是比java强大）
静态成员包括静态对象。
友元函数
可以实现两个类之间无限制的存取另一个类的成员。
友元函数可以访问私有成员，公有成员和保护成员。友元函数可以是一个类或函数。友元需要通过对象来使用类的成员。
友元的三种形式：
1.普通函数作为一个类的友元
例子：
arduino复制代码  class Point{
  
     double x,y;
   public:
      Point(double x1,double y1){x = x1, y =y1}
      friend double max(Point &amp; p1,Point &amp; p2);
  };
  
  double max(Point &amp;p1,Point &amp;p2){  //注意，此函数为Point类的友元函数，与其成员函数有区别
    return p1.x+p1.y &gt; p2.x+p2.y ? p1.x+p1.y : p2.x+p2.y; 
  }

2.a类的成员函数作为b类的友元
例子：
kotlin复制代码 class A{
   private:
      int x;
   public:
      A(int a){x = a;}
      int getX(){return x;}
      void fun(B &amp; t);
 };
 
 class B{
  private:
     int y;
  public:
     B(int b){y = b;}
     int getY(){return y;}
     friend void A::fun(B &amp; t);
 };
 
 void A::fun(B &amp; t){
   t.y = x;
 }

3.a类作为b类的友元
arduino复制代码  class B{
  
   private:
      int y;
   public:
      B(int b){y = b;}
      int getY(){return y;}
      friend class A;
  }

const对象
const 可限定变量、指针、对象
函数、数据成员、成员函数。便是不可改变。
const对象只能调用const成员函数
例子：
arduino复制代码 class circle{
   private:
     double r;
     const double PI;
     static int count;
   public:
     circle(double a):PI(3.14159265354){ //此即为const成员函数的定义方式
      r = a;
      count = count+1;
     }
 
 }

main函数
main函数为入口函数，与java类似，但是只能有一个main
继承和派生
继承和派生的基本概念
继承关系是类与类之间的类属关系（从概念上来说，与Java类似，但是java只支持单一继承）
类的继承是指：派生类继承基类的所有数据成员和成员函数。用于表示类之间的类属关系，非构成关系。
派生类的特点：
1.增加新成员。
2.重定义已有成员函数。
3.改变基类的成员的访问权限。
单一继承

一般形式
arduino复制代码 class 派生类名：访问控制 基类名{
   private:
      成员列表；
   public:
      成员列表；       
   protected：
      成员列表；   
 }


派生类的构造函数和析构函数
派生类中继承的基类的成员初始化时，需要由派生类的构造函数调用基类的构造函数。
派生类的构造函数一般形式：
派生类名::派生类名(参数):基类名（参数）{
//函数体
}
构造函数和析构函数不能被继承。
类的保护成员protected
派生类使用基类的私有成员，保持封装性，可以将私有限定改为protected（与java类似）
访问权限
赋值兼容规则
isa和has-a的区别
isa关系：继承和派生关系。
has-a关系：一个类使用另一个类的对象作成员。
公有继承关系一般和isa关系是等价的。
公有继承存取权限表






























基类派生类基类对象派生类对象private不可访问不可访问不可访问publicpublic可访问可访问protectedprotected不可访问不可访问


私有派生
定义派生时，用private限定 。基类的公有成员和保护成员变为私有成员。


保护派生
定义派生时，用proetcted限定 。
降级使用，基类中的private变为不可访问，protect变为private，public变为protected。


多重继承
一般形式（java只能单一继承，c++可以多重继承）：
class 类1:访问控制 lei2，访问控制 类3{
private：
//私有成员
protected：
//保护成员
public：
//公有成员
}
二义性及其支配原则


作用域和成员名限定
当派生类中从多个基类中继承得到同名函数时，在派生类中使用这些函数时，须使用类名限定！派生类的对象使用这些函数时，也需要进行类名限定！


派生类支配基类的同名函数
在基类和派生类有重名的成员时，优先派生类的成员，如果要访问基类成员，必须加上左右域符号 ::
私有成员派生类不可访问，只有本类和友类可以访问
如果派生类要访问基类的成员，基类成员应该用protected限定。


类模版与向量
类模版

类模版的基础知识
arduino复制代码template&lt;class T&gt; class 类名{
 .....
}



xml复制代码类模版的对象：类名&lt;模版参数&gt; 对象名（参数）； 

kotlin复制代码模版类的成员函数定义形式： 
template&lt;class T&gt; 返回值类型 类名&lt;T&gt;::函数名（参数）{
  //函数体
}


类模版的派生与继承
模版类继承普通类，模版类作普通类的派生类。
继承后成员使用与一般类的继承成员使用一样。
模版类派生模版类。
模版类使用时，须指出模版类参数。

向量与泛型算法


定义向量列表
向量是c++中一维数组的类版本，用于存放多个相同类型的数据。
可以动态指定向量中元素的个数。可以使用泛型算法。（可类比java中的集合）
向量的声明形式：
vector &lt;类型&gt; 向量名；
vector &lt;类型&gt; 向量名(长度);
vector &lt;类型&gt; 向量名(长度，a);
vector &lt;类型&gt; 向量名1(向量名2);
vector &lt;类型&gt; 向量名(a,a+长度);
以上所说的a是数组名。


向量的数据类型
向量不仅可存取int，double等普通数据类型，也可以存储对象，指针，对象的指针。


向量的基本操作方法
类比数组，以及使用泛型算法。


多态性和虚函数
多态性

赋值兼容规则是指在需要基类对象的du任何地方都可以使用zhi公有派生类的对象来替代。通过公有dao继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。赋值兼容规则中所指的替代包括以下的情况：

　　   1.派生类的对象可以赋值给基类对象。
　　   2.派生类的对象可以初始化基类的引用。
　　   3.派生类对象的地址可以赋给指向基类的指针。

静态联编中的赋值兼容性和名字支配规律。
类的对象和调用的函数一一对应，程序编译时即可确定对象调用哪个函数，称为静态联编。
通过指针调用成员函数时：所调用成员函数为指针所属类的成员函数，即有赋值兼容规则决定指针调用的成员函数
动态联编的多态性
要实现程序运行时决定指针所调用的函数是基类的还是派生类的，即：动态联编。可以利用虚函数实现动态联编。

虚函数


虚函数的格式：
virtual double area(){
return 0;
}
虚函数不能是静态成员。


虚函数实现多态性
使用虚函数实现多态的三个前提：
1.类之间的继承关系满足赋值兼容性规则；
2.改写了同名虚函数；
3.根据赋值兼容性规则使用指针（或引用）。


构造函数和析构函数调用虚函数
标准c++不支持虚构造函数  ，支持虚析构函数。


纯虚函数与抽象类
1.纯虚函数的格式
class 类名{
virtual 函数类型 函数名（参数列表）=0；
}
2.抽象类
包含纯虚函数的类称为抽象类
抽象类的派生类如果没有实现抽象类中的全部纯虚函数，这个派生类依旧是抽象类。
纯虚函数与空的虚函数是不同的：
1.virtual void area()=0;  //纯
2.virtual vodi area(){}  //空


多重继承与虚函数
首先，多重继承是多个单一继承的集合。
类成员函数的指针与多态性
在派生类中，当一个指向基类成员函数的指针指向一个虚函数，并且通过指向对象的基类指针（或引用）访问这个虚函数时，会发生多态性。
运算符重载和流类库
运算符重载


重载对象的赋值运算符


运算符重载的实现


&lt;&lt; &gt;&gt; 和 ++ 运算符重载的实例
例子：
kotlin复制代码  //插入符函数的一般形式
 ostream &amp;operator&lt;&lt;(ostream&amp; output,类名&amp; 对象名){
    return output;
 }



类运算符和友元运算符的区别


下标运算符 “[ ]”的重载


流类库


流类库的基础类
把接收输出数据的地方叫做 目标
把输入数据来自的地方叫做 源头

.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:&quot;&quot;}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}为什么要学习C++：
       抛开C++在一些物联网，高性能引擎（游戏等）及各种操作系统等行业使用的专业性，不论作为java开发还是其他开发，我们的知识体系里面必不可少的定有操作系统相关的知识，而关于操作系统，如果我们想要更深入的了解的话，看懂它的一些代码当然是必不可少的。再或者，开发一些高性能的工具或者组件,这些，都离不开C和C++，而对于C++的学习其实就基本上已经学会了C的一些东西（如果以前没有接触过C的话），基于二八法则，基本已够用。
C++语言的由来：
       1982年，美国AT&amp;T公司贝尔实验室的Bjarne Stroustrup(本贾尼·斯特劳斯特卢普)博士在C语言的基础上引入并扩充了面向对象的概念，从而创造了C++这门程序语言，也叫做带类的C（c with class）。Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）博士也被尊称为C++语言之父。
推荐c++学习开发工具
  windows上使用vc即可，mac上使用xcode即可
强烈推荐使用Qt creator 学习开发，也可以学习下Qt库
C++语法
认识C++的对象:
C++的函数和对象：

注释方式(基本与java注释类似)

arduino复制代码/*....*/  
//.... 


输入输出流
cin和cout是C++语言中进行输入输出操作的函数，定义在istream头文件中。
例子：

bash复制代码cout &lt;&lt; &quot;&quot; &lt;&lt; endl;  //c代表c系语言，out代表输出，endl代表换行 


使用命名空间
命名空间是C++语言中封装程序库名称的一种机制
C++ 标准类库中的对象和函数都属于std命名空间，使用这些函数和对象时要using namespace std
arduino复制代码#include &quot;iostream&quot; //包含头文件
#include &quot;cmath&quot;
using namespace std


使用std命名空间时注意：
使用c语言中的头文件时，要写成“xxx.h”形式
使用c++中的头文件则不能加上“.h”
命名空间可自定义，可嵌套，比如小王定义的是A命名空间，小李定义的是B命名空间，就算他们的函数重名了，一摸一样了也没事，可以通过命名空间::函数名来调用。


对象的定义及初始化
c语言：int x; x=0; 等价于 int x=0;
c++ 语言（等价于上两条c语句）：int x(0); 此种初始化语法在c++中称为构造函数语法
函数原型及其返回值
函数要有类型，若要得到处理结果则要使用return语句（与java类似，其实java的面世很多都是参考c++）。
例子：
    int result(int a,int b){  int d;  d = a+b;  return d;     }    
函数调用在函数定义之前时要对函数进行声明
例子：
    int result(int a,int b); //进行函数声明     void main(){ //主函数 ... z = result(x ,y); //调用定义的函数 ...     }     int result(int a,int b){ //定义函数 int d; d = a+b; return d;     }    
const修饰符和预处理程序
常量定义：（在c语言中是这样定义的，注意c++语法包含容纳c语法，c++就像是对c的一个扩充） #define PI 3.1415
(在c++中是这样定义的) 在变量定义之前加上const关键字，类似java，表示定义的变量值不可改变。
const int PI = 3.1415; （第一种）
const int PI(3.1415); （第二种，即构造函数语法）
利用const定义常量时必须给出常量的值，除非该常量是extern（外部变量、即全局变量）的。
以#开始，分为宏定义，文件包含和条件编译。
程序的书写规则
注意缩进对齐，区分大小写，类似java，有所不同。

C++语言面向过程编程的特点


函数重载
（与java类似）C++允许一个函数定义多个版本，使得一个函数完成多种功能，即同一个函数名定义多次。
例子：
css复制代码 int max(float a,float b){
  return a &gt; b ? a:b;
 }
 
 int max(int a,int b,int c){
 int d;
 d = a &gt; b ? a:b;
 return d &gt; c ? d:c;
 }
 int max(int a,int b){
  return a&gt;b ? a:b;
 }

如例子所示，重载函数的特点：
函数名相同，参数个数不同，或者参数类型不同。


C++的数据类型（包括java等，几乎所有有语言的数据类型都囊括这些）
1.void类型
void表示空类型，或者无类型，表示函数无返回值。
2.bool类型（逻辑型，布尔型）
占1个字节，表示逻辑运算符中的 真 、假。
3.整型（int、  long、 short）
int、short至少16位
long至少32位
short不得比int长
int 不得比long长
4.char型（字符型）
占1个字节。
5.实型（float/double/long  double）
我们可以通过sizeof来观察这些数据类型的长度
例子：
c复制代码 cout &lt;&lt; sizeof(bool) &lt;&lt; endl;
 cout &lt;&lt; sizeof(int) &lt;&lt; endl;
 cout &lt;&lt; sizeof(short) &lt;&lt; endl;
 cout &lt;&lt; sizeof(long) &lt;&lt; endl;
 cout &lt;&lt; sizeof(char)  &lt;&lt; endl;
 cout &lt;&lt; sizeof(float) &lt;&lt; endl;
 ......

6.&amp;取地址符（取某一个变量的地址）
例子：
css复制代码int x;
int *p;  //p是指针变量，指针变量能存放变量的地址
p = &amp;x; //&amp;x表示取出变量x的地址，p = &amp;x表示将变量x的地址取出后存入指针变量p

7.常量表示
整型：
0前缀表示8进制数，0x前缀表示16进制数，加L、I后缀表示长整型常量
实型：
F、f后缀表示浮点型常量（float）；
实数加L、I后缀表示long double类型；
无前缀、无后缀的为double类型；


动态分配内存
new动态分配内存
一般格式： 指针变量 = new 类型[size];
new 运算符得到新分配空间的首地址、赋值给指针变量后，可根据指针变量的加减运算来使用这些空间。
（与java不同，java有垃圾回收机制，自动释放内存，而c++是没有的）
delete 释放内存，使用完毕后要释放内存。
delete p;


引用的使用方法
引用即使用变量的别名。
定义形式：数据类型 &amp; 别名 = 对象名；
作用：别名与对象名对应同一个对象，共用同一段内存。对别名的修改会造成原对象的修改。
例子：
    int x;     int &amp; a = x; //a是变量x的别名，a和x完全等价    
使用别名时的注意事项：
1.不能定义引用的引用，如错误示范： int &amp; &amp;r=x;
2.不能直接定义数组的引用


arduino复制代码使用typedef定义某类型的别名   

arduino复制代码一般格式：typedef 类型 类型别名  
例子：
</code></pre>
<p>typedef long int lint;<br>
//long int i;<br>
lint i; //lint i 等价于 long int i</p>
<pre><code>


对指针使用const限定符
1.左值和右值
表达式：E1 = E2 ； E1是左值，是可被修改的；
int *p,x = 1;
*p = 2;  &amp;p表示指针p的地址
2.指向常量的指针和常量指针
const常量定义：表示const后的表达式不可改变，定义时必须给出表达式的值。
例子：
    int x = 11;     const int *p; //错误写法，必须初始化     const int *p = &amp;x; //错误写法，*p是不能在=的左边     int * const p = &amp;x; //正确写法（注意：p不可改变，但是*p可变）      


复制代码3.指向常量的常量指针  

ini复制代码例子：
</code></pre>
<p>int x = 11;<br>
const int * const p = &amp;x; //表示p不可变，*p也是不可变的</p>
<pre><code>


泛型算法应用于普通数组
泛型算法是C++标准模版库（Standard Template Library）提供的一组操作。利用这些操作可以简化数组操作。
要使用这些操作必须包含头文件&lt;algorithm&gt;
假定a,b是两个数组名，其长度为len
例子：
      reverse(a,a+len); //将数组a中的元素顺序反转（逆向），注意，len需要替换成长度，比如len=5，则len应该换成5     copy（a,a+len,b）; //将a数组的内容原样复制给b数组      reverse_copy(a,a+len,b); //将a数组的内容反转后复制给b数组       sort(a,a+len) ;//将数组a中的元素按升序排序      sort(a,a+len,greater&lt;type&gt;()) ;//将数组a中的元素按降序排序，type是数据类型，比如type是int，应该将type替换成int       find(a,a+len,value);//在数组a中查找值为vavlue的元素，并返回位置指针       copy(a,a+len,Ostream_iterator&lt;type&gt;(cout,&quot;分隔字符串&quot;)); //Ostream_iterator表示输出流操作符，&lt;type&gt;表示要输出的数组类型，cout表示流输出操作，“分隔字符串”即就是分隔字符的    


程序的编辑、翻译、运行
程序从无到有为编辑，出来的c++源代码
对比C和C++文件的各种后缀（由于历史原因，可谓花样真多，现在只展示统一的）：




























语言头文件源文件c.h.cc++.h,但是openCV采用 .hppwindows平台 .cpp,linux平台 .cc源码进行编译为翻译        c++的编译器有不少，其中熟知的有MSVC、GCC、Cygwin、MingW（Cygwin和MingW的英文发音），另外还有些    小众和新秀，像ICC（Intel C/C++ Compiler）、BCC（Borland C/C++ Compiler，快销声匿迹了）、RVCT    （ARM的汇编/C/C++编译器，内置在ARM的IDE——RVDS中）、Pgi编译器……
我们在linux下最常用的：
GCC原名GNU C Compiler，后来逐渐支持更多的语言编译（C++、Fortran、Pascal、Objective-C、         Java、Ada、Go等），所以变成了GNU Compiler Collection（GNU编译器套装），是一套由GNU工程开发的支    持多种编程语言的编译器。GCC是自由软件发展过程中的著名例子，由自由软件基金会以GPL协议发布，是大多数类      Unix（如Linux、BSD、Mac OS X等）的标准编译器，而且适用于Windows（借助其他移植项目实现的，比如        MingW、Cygwin等）。GCC支持多种计算机体系芯片，如x86、ARM，并已移植到其他多种硬件平台.
有时候，在linxu中下载一些第三方工具，提示我们需要下载相关gcc依赖等，就是因为这个工具由于c++开发，需要使用gcc进行编译才可执行使用。


执行即为c++编译后的文件，进行汇编和链接后的执行
从结构到类的演变：
结构的演化：


结构发生质的演变
1.函数与数据共存
c++允许结构中定义的函数，成为成员函数。在结构中同时定义成员变量和成员函数。
使用格式：
结构对象.成员变量
结构对象.成员函数
例子：
</code></pre>
<p>#include    //引入头文件 io<br>
using namespace std; //使用c++标准类库中的类，需要使用std命名空间<br>
struct point{ //point即为结构名，结构是c++中的一种数据结构,类似类<br>
double x,y;<br>
void updatexy(double a, double b){<br>
x = a;<br>
y = b;<br>
}<br>
void display(){<br>
cout &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; y &lt;&lt; endl; //endl是换行的意思<br>
}<br>
}; //注意结构数据定义完后要有分号</p>
<p>csharp复制代码void main(){</p>
<p>css复制代码 point p; //表示定义了p，与java不一样的是，这个p已经包含了java中= new .. 后面的动作，所以可直接调用p<br>
p.updatexy(1.5,1.7);<br>
p.display();<br>
cout &lt;&lt; p.x &lt;&lt; &quot;\t&quot; &lt;&lt; p.y &lt;&lt; endl;<br>
}</p>
<pre><code>
2.封装
如果定义结构体时，使用了private关键字，则产生封装性。
例子：
csharp复制代码struct point{
 private: //这里区别于java，可以只写一个private，所有private的放在其下
  double x,y;  //这时候，在main中，通过point的变量名直接 . 变量，就不行了
 public:  //区别于java，可以只写一个public....
  void updatexy(double a,double b){
   x = a;
   y = b;
  }
  void display(){
  cout &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;
  }  
};

在定义结构时，如果使用了private则产生封装性，表示成员为私有的，只能在结构体内部通过公有成员函数使用。如果未添加private，则表示默认为public。值得注意的是类在定义时默认却为private。

使用构造函数初始化结构的对象
在定义结构时，与结构同名的函数称为构造函数。
如果定义的函数与某个已定义函数重名而参数类型或者个数不同，则称为函数重载。
例子：

ini复制代码struct point{
private:
  double x,y;
public:
  point(){};
  point(doube a,double b){
   x = a;
   y = b;
  }
  void updatexy(....){ ... } 
  .....
}

与java的类类似，构造函数在定义结构体对象时自动执行，并根据是否初始化来自动选择所调用的构造函数。
这里需要区分的是：java的对象定义，在定义后，如果不new对象，它的变量名对应的对象则为null（这个null需要我们给赋给其），如果new对象的话，不仅会创建一个对象，还会自动进行初始化，也就是java的对象创建流程里面已经包含了初始化。但是c++则不一样，（c++也有new对象的方式，new出来的为动态对象）c++定义好后，就已经有这个对象了，但是初始化的过程由我们来控制，可以调用有参数的构造函数，那在对象定义完成后，也已经完成了初始化过程。
结构演化成一个简单的类：
将结构的struct替换为class即变为类的标准定义形式。
例子：
ini复制代码class point{
 private:
   double x,y;
 public:
   point(){};
   point(double a,double b){
   x = a;
   y = b;
   };  
   void updatexy(double a,double b){
   x = a;
   y = b;
   }
   void display(){
    cout &lt;&lt; a &lt;&lt; &quot;\t&quot; &lt;&lt; b &lt;&lt; endl;
   }   
};

类图的表示（UML即统一建模语言等）：


















point-x : double   -y : double+point()   +updatexy() +display()其中，point为类名，x，y为类属性（成员变量），point和updatexy、display为类操作（成员函数）。
面向过程和面向对象：
直观的从一道题来区分：
给出两点坐标，计算亮点间距，并输出。
1.面向过程的求解步骤 ：
步骤：
+ 输入x1，y1,x2,y2 四个数据
计算（x1,y1）和 (x2,y2)的距离
输出计算出的距离
2.面向对象的求解步骤
+ 设计类
将点设计为一个类，并提供相关的属性和操作
定义对象同时给出坐标
point A(x1,y1)
point B(x2,y2)
定义对象，然后获取坐标
计算距离并输出
C++面向对象程序设计特点

对象
三要素：对象名，属性，操作

使用类和对象

使用类和对象
1.使用string对象



















string- str+string()   +find() +size()  +substr该类是c++语言中的内部预定义类，要在程序中使用该类时必须添加头文件  #include &lt;string&gt;  ；
**注意:**头文件引入的两种写法，#include  &lt;...&gt; 和 #include &quot;...&quot;  。
类的初始化：string str1 = &quot;A&quot;;
string str1(&quot;hello  &quot;);
string str2 = &quot;world&quot;;
与java类似，string对象允许使用 + 运算
* 使用complex对象
complex类用于定义一个复数对象，使用时添加头文件 #include &lt;comlex&gt;
定义格式：complex &lt;int&gt; num1(1,2);
* 使用对象总结
使用标准类库中的类时，必须添加头文件。
定义对象方式同变量定义方式类似。
定义对象时可对对象进行初始化。
同类的不同对象由对象属性来区分。
不同类的对象具有不同的成员函数可实现不同操作。
类是具有相同特征和操作的对象的抽象。
函数和函数模版
函数的参数及其传递方式
c语言中参数传递方式只有一种：值传递（值传递分为变量值传递和变量地址值传递）。
c++中分为：值传递和地址传递（引用传递），与java类似。
参数不同传递形式：对象作参数，对象指针作参数，对象引用作参数。
引用的声明形式：
数据类型 &amp;别名 = 对象名；
int x = 21;
int &amp;a = x;
引用对象不是一个对立对象，与原对象同用一个地址空间，不占用内存。
对象的指针作参数时，指针变量中存放实参对象的地址。
函数的返回值
与java类似，但是多了指针类型。
内联函数
定义函数时，加inline关键字表示该函数为内联函数。
例子：
arduino复制代码inline int wheatherNumber(char c){
 return c &gt; '0' &amp;&amp; c &lt; '9' ? 1:0;
}

程序中的内联函数在程序编译时，将函数替换至程序中函数调用位置，造成程序变长，效率提高。
注意事项：
内联函数中不能出现循环、switch语句等
内联函数一般短小，不宜过长
应在调用之前声明或定义
函数模版
有些函数重载时参数个数相同，只是类型不同，此时重载函数比较繁琐，可利用函数模版实现。
例子：
ini复制代码template &lt;class type&gt;  
type max(type a , type b){
  return a &gt; b ? a:b;
}

void main(){
  int x = 1,y = 2;
  double x1 = 1.2,y = 2.1;
  
  int z;
  double z1;
  
  z = max(x,y);
  z1 = max(x1,y1);
  cout &lt;&lt; &quot;最大值：int类型为 &quot; &lt;&lt; z &lt;&lt; &quot;  dobule类型为  &quot; &lt;&lt; z1 &lt;&lt;endl;

}


定义函数模版后，函数调用时根据函数参数类型来确定调用哪个版本的函数。函数执行时确定参数类型的函数称为模版函数。
类和对象
类及其实例化


类的定义
例子模版：
</code></pre>
<p>class 类名{<br>
private:<br>
//私有的数据成员和成员函数<br>
public:<br>
//公有的数据成员和成员函数<br>
protected:<br>
//保护的数据成员和成员函数<br>
};<br>
void 类名::函数名(){<br>
}</p>
<p>go复制代码```</p>
<p>:: 称为域限定符，表示函数是类的成员函数。在类外使用域限定符定义函数，若想定义为内联，加inline关键字就即可。<br>
类内定义的函数默认为内联函数。</p>
<p>使用类的对象<br>
类的对象的使用类似变量的使用。<br>
声明/定义对象，直接利用对象名使用，通过对对象的引用使用对象，通过指向对象的指针使用对象。<br>
数据封装<br>
与结构体封装类似</p>
<p>构造函数</p>
<p>默认构造函数<br>
若类的定义中未定义构造函数，则c++编译器会自动产生一个不带参数的默认构造函数，类似于：point(){},此时不对对象进行初始化。若类中定义了构造函数，则不再产生默认构造函数。</p>
<p>定义构造函数<br>
构造函数无返回值，这样可以减少编译器的工作，提高效率。<br>
构造函数与类同名。<br>
构造函数可以重载。<br>
构造函数系统自动调用。</p>
<p>构造函数和运算符new<br>
new 和构造函数一同起作用，即new首先给对象分配内存，然后自动调用构造函数来初始化这块内存。<br>
例子：</p>
<pre><code>void main(){
Point *ptr = new Point;
Point *ptr1 = new Point(1,2);
delete ptr;
delete ptr1;
}
</code></pre>
<p>new建立的动态对象只能用delete删除，并会释放空间。</p>
<p>复制构造函数<br>
&lt;类名&gt;::&lt;复制初始化构造函数&gt;(const 类名 &amp;引用名)</p>
<p>析构函数<br>
           析构函数的调用由编译器自动调用，析构函数名在类名前加～，析构函数无返回值，析构函数无参数，可以显示说明为void，析构函数不可以重载，析构函数在对象生命周期结束的时候由系统自动调用。</p>
<p>定义析构函数<br>
例子：<br>
arduino复制代码class Point{<br>
private:<br>
int x,y;<br>
public :<br>
Point(const Point&amp;);<br>
Point(int a = 10,int b = 10);<br>
~Point();</p>
<p>}<br>
……</p>
<p>类的对象组的每个元素调用一次构造函数，调用一次析构函数。<br>
全局对象数组的析构函数在程序结束之前会被调用。</p>
<p>析构函数和运算符delete<br>
delete后自动调用析构函数。与new 相反。</p>
<p>默认析构函数<br>
编译器为没有析构函数的类自动产生一个空体析构函数，与构造函数类似。<br>
分配几次内存调用几次构造函数，释放几次内存，调用几次析构函数。</p>
<p>this指针<br>
       this指针是c++实现粉状的一种机制，它将对象和该对象调用的成员函数连接在一起。this指针保证了每个对象可以拥有自己的数据成员。（跟java类似）<br>
例子：<br>
ini复制代码Point::Point(int a=0,int b=0){<br>
this-&gt;x=a;<br>
this-&gt;y=b;<br>
}<br>
point::Point(const Point &amp;p){<br>
this-&gt;x=p.x;<br>
this-&gt;y=p.y;<br>
}</p>
<p>类和对象的性质</p>
<p>对象的性质<br>
1.同一类的对象之间可以互相赋值；<br>
2.可以使用对象数组；<br>
3.可以使用指向对象的指针；<br>
4.对象可以用作函数参数；<br>
5.对象作为函数参数时，可以使用对象、对象引用和对象指针；<br>
6.一个对象可以用作另一个类的成员。<br>
类的性质<br>
1.使用类的权限<br>
2.不完全的类声明<br>
只有当使用类产生的对象时，才进行内存分配。<br>
类没有完全定义之前就引用该类。<br>
不完全声明仅用于类和结构<br>
3.空类<br>
4.类作用域<br>
类中默认控制权限是private</p>
<p>面向对象编程的文件规范</p>
<p>编译指令<br>
在头文件中使用条件编译<br>
#if<br>
...</p>
<p>特殊函数和成员<br>
静态成员<br>
成员定义时使用static关键字<br>
1.静态成员变量的初始化只能在类外进行。<br>
2.类中的任何成员函数都可以访问静态成员变量。<br>
3.访问静态成员时，一般加上类名限定。<br>
4.静态成员变量是类的成员，不是对象的成 员。<br>
5.对象未建立之前静态成员已经存在。<br>
6.静态成员没有this指针，除非使用引用方式，否则不能存取类的成员。（与java类似，但是比java强大）<br>
静态成员包括静态对象。<br>
友元函数<br>
可以实现两个类之间无限制的存取另一个类的成员。<br>
友元函数可以访问私有成员，公有成员和保护成员。友元函数可以是一个类或函数。友元需要通过对象来使用类的成员。<br>
友元的三种形式：<br>
1.普通函数作为一个类的友元<br>
例子：<br>
arduino复制代码  class Point{</p>
<pre><code> double x,y;
</code></pre>
<p>public:<br>
Point(double x1,double y1){x = x1, y =y1}<br>
friend double max(Point &amp; p1,Point &amp; p2);<br>
};</p>
<p>double max(Point &amp;p1,Point &amp;p2){  //注意，此函数为Point类的友元函数，与其成员函数有区别<br>
return p1.x+p1.y &gt; p2.x+p2.y ? p1.x+p1.y : p2.x+p2.y;<br>
}</p>
<p>2.a类的成员函数作为b类的友元<br>
例子：<br>
kotlin复制代码 class A{<br>
private:<br>
int x;<br>
public:<br>
A(int a){x = a;}<br>
int getX(){return x;}<br>
void fun(B &amp; t);<br>
};</p>
<p>class B{<br>
private:<br>
int y;<br>
public:<br>
B(int b){y = b;}<br>
int getY(){return y;}<br>
friend void A::fun(B &amp; t);<br>
};</p>
<p>void A::fun(B &amp; t){<br>
t.y = x;<br>
}</p>
<p>3.a类作为b类的友元<br>
arduino复制代码  class B{</p>
<p>private:<br>
int y;<br>
public:<br>
B(int b){y = b;}<br>
int getY(){return y;}<br>
friend class A;<br>
}</p>
<p>const对象<br>
const 可限定变量、指针、对象<br>
函数、数据成员、成员函数。便是不可改变。<br>
const对象只能调用const成员函数<br>
例子：<br>
arduino复制代码 class circle{<br>
private:<br>
double r;<br>
const double PI;<br>
static int count;<br>
public:<br>
circle(double a):PI(3.14159265354){ //此即为const成员函数的定义方式<br>
r = a;<br>
count = count+1;<br>
}</p>
<p>}</p>
<p>main函数<br>
main函数为入口函数，与java类似，但是只能有一个main<br>
继承和派生<br>
继承和派生的基本概念<br>
继承关系是类与类之间的类属关系（从概念上来说，与Java类似，但是java只支持单一继承）<br>
类的继承是指：派生类继承基类的所有数据成员和成员函数。用于表示类之间的类属关系，非构成关系。<br>
派生类的特点：<br>
1.增加新成员。<br>
2.重定义已有成员函数。<br>
3.改变基类的成员的访问权限。<br>
单一继承</p>
<p>一般形式<br>
arduino复制代码 class 派生类名：访问控制 基类名{<br>
private:<br>
成员列表；<br>
public:<br>
成员列表；<br>
protected：<br>
成员列表；<br>
}</p>
<p>派生类的构造函数和析构函数<br>
派生类中继承的基类的成员初始化时，需要由派生类的构造函数调用基类的构造函数。<br>
派生类的构造函数一般形式：<br>
派生类名::派生类名(参数):基类名（参数）{<br>
//函数体<br>
}<br>
构造函数和析构函数不能被继承。<br>
类的保护成员protected<br>
派生类使用基类的私有成员，保持封装性，可以将私有限定改为protected（与java类似）<br>
访问权限<br>
赋值兼容规则<br>
isa和has-a的区别<br>
isa关系：继承和派生关系。<br>
has-a关系：一个类使用另一个类的对象作成员。<br>
公有继承关系一般和isa关系是等价的。<br>
公有继承存取权限表</p>
<p>基类派生类基类对象派生类对象private不可访问不可访问不可访问publicpublic可访问可访问protectedprotected不可访问不可访问</p>
<p>私有派生<br>
定义派生时，用private限定 。基类的公有成员和保护成员变为私有成员。</p>
<p>保护派生<br>
定义派生时，用proetcted限定 。<br>
降级使用，基类中的private变为不可访问，protect变为private，public变为protected。</p>
<p>多重继承<br>
一般形式（java只能单一继承，c++可以多重继承）：<br>
class 类1:访问控制 lei2，访问控制 类3{<br>
private：<br>
//私有成员<br>
protected：<br>
//保护成员<br>
public：<br>
//公有成员<br>
}<br>
二义性及其支配原则</p>
<p>作用域和成员名限定<br>
当派生类中从多个基类中继承得到同名函数时，在派生类中使用这些函数时，须使用类名限定！派生类的对象使用这些函数时，也需要进行类名限定！</p>
<p>派生类支配基类的同名函数<br>
在基类和派生类有重名的成员时，优先派生类的成员，如果要访问基类成员，必须加上左右域符号 ::<br>
私有成员派生类不可访问，只有本类和友类可以访问<br>
如果派生类要访问基类的成员，基类成员应该用protected限定。</p>
<p>类模版与向量<br>
类模版</p>
<p>类模版的基础知识<br>
arduino复制代码template<class T> class 类名{<br>
.....<br>
}</p>
<p>xml复制代码类模版的对象：类名&lt;模版参数&gt; 对象名（参数）；</p>
<p>kotlin复制代码模版类的成员函数定义形式：<br>
template<class T> 返回值类型 类名<T>::函数名（参数）{<br>
//函数体<br>
}</p>
<p>类模版的派生与继承<br>
模版类继承普通类，模版类作普通类的派生类。<br>
继承后成员使用与一般类的继承成员使用一样。<br>
模版类派生模版类。<br>
模版类使用时，须指出模版类参数。</p>
<p>向量与泛型算法</p>
<p>定义向量列表<br>
向量是c++中一维数组的类版本，用于存放多个相同类型的数据。<br>
可以动态指定向量中元素的个数。可以使用泛型算法。（可类比java中的集合）<br>
向量的声明形式：<br>
vector &lt;类型&gt; 向量名；<br>
vector &lt;类型&gt; 向量名(长度);<br>
vector &lt;类型&gt; 向量名(长度，a);<br>
vector &lt;类型&gt; 向量名1(向量名2);<br>
vector &lt;类型&gt; 向量名(a,a+长度);<br>
以上所说的a是数组名。</p>
<p>向量的数据类型<br>
向量不仅可存取int，double等普通数据类型，也可以存储对象，指针，对象的指针。</p>
<p>向量的基本操作方法<br>
类比数组，以及使用泛型算法。</p>
<p>多态性和虚函数<br>
多态性</p>
<p>赋值兼容规则是指在需要基类对象的du任何地方都可以使用zhi公有派生类的对象来替代。通过公有dao继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。赋值兼容规则中所指的替代包括以下的情况：</p>
<p>1.派生类的对象可以赋值给基类对象。<br>
　　   2.派生类的对象可以初始化基类的引用。<br>
　　   3.派生类对象的地址可以赋给指向基类的指针。</p>
<p>静态联编中的赋值兼容性和名字支配规律。<br>
类的对象和调用的函数一一对应，程序编译时即可确定对象调用哪个函数，称为静态联编。<br>
通过指针调用成员函数时：所调用成员函数为指针所属类的成员函数，即有赋值兼容规则决定指针调用的成员函数<br>
动态联编的多态性<br>
要实现程序运行时决定指针所调用的函数是基类的还是派生类的，即：动态联编。可以利用虚函数实现动态联编。</p>
<p>虚函数</p>
<p>虚函数的格式：<br>
virtual double area(){<br>
return 0;<br>
}<br>
虚函数不能是静态成员。</p>
<p>虚函数实现多态性<br>
使用虚函数实现多态的三个前提：<br>
1.类之间的继承关系满足赋值兼容性规则；<br>
2.改写了同名虚函数；<br>
3.根据赋值兼容性规则使用指针（或引用）。</p>
<p>构造函数和析构函数调用虚函数<br>
标准c++不支持虚构造函数  ，支持虚析构函数。</p>
<p>纯虚函数与抽象类<br>
1.纯虚函数的格式<br>
class 类名{<br>
virtual 函数类型 函数名（参数列表）=0；<br>
}<br>
2.抽象类<br>
包含纯虚函数的类称为抽象类<br>
抽象类的派生类如果没有实现抽象类中的全部纯虚函数，这个派生类依旧是抽象类。<br>
纯虚函数与空的虚函数是不同的：<br>
1.virtual void area()=0;  //纯<br>
2.virtual vodi area(){}  //空</p>
<p>多重继承与虚函数<br>
首先，多重继承是多个单一继承的集合。<br>
类成员函数的指针与多态性<br>
在派生类中，当一个指向基类成员函数的指针指向一个虚函数，并且通过指向对象的基类指针（或引用）访问这个虚函数时，会发生多态性。<br>
运算符重载和流类库<br>
运算符重载</p>
<p>重载对象的赋值运算符</p>
<p>运算符重载的实现</p>
<p>&lt;&lt; &gt;&gt; 和 ++ 运算符重载的实例<br>
例子：<br>
kotlin复制代码  //插入符函数的一般形式<br>
ostream &amp;operator&lt;&lt;(ostream&amp; output,类名&amp; 对象名){<br>
return output;<br>
}</p>
<p>类运算符和友元运算符的区别</p>
<p>下标运算符 “[ ]”的重载</p>
<p>流类库</p>
<p>流类库的基础类<br>
把接收输出数据的地方叫做 目标<br>
把输入数据来自的地方叫做 源头</p>
<p>作者：清水河畔<br>
链接：https://juejin.cn/post/6869005618854936583<br>
来源：稀土掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
</feed>